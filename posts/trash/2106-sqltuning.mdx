---
title: "업무에 바로 쓰는 SQL 튜닝"
date: 2021-06-20 08:00
tags:
- 독서
- SQL
description: 더 효율적인 쿼리를 짜기 위해
unpublished: true
---

## MySQL과 Oracle의 차이

1. 데이터가 저장되는 스토리지의 구조 차이

- 오라클 DB는 통합된 스토리지 하나를 공유 vs MySql은 물리적인 DB서버마다 독립적인 스토리지를 할당
- 공유 스토리지를 사용하는 오라클은 사용자가 어느 DB 서버에 접속하던 같은 결과가 출력되고 동일한 CRUD 처리 가능
- MySQL은 주로 master-slave 구조. 마스터 노드는 CRUD 수행가능, 슬레이브는 읽기만 가능. = DB 서버마다 각 역할이 나뉠 수 있다.

2. 지원하는 기능 차이

- MySQL은 조인 시 대부분 nested loop join, Oracle은 nested loop join, sort merge join(정렬 병합 조인)과 해시 조인 사용.
- MySQL은 스토리지 엔진이라는 개념을 포함하기에 오픈소스 DBMS를 바로 꽂아 사용할 수 있는 확장성을 지님 (plug & play)
- MySQL은 오라클 대비 낮은 메모리 사용. 저사양 PC에도 적합.
- MySQL은 데이터가 변경되면 메모리의 캐시를 모두 삭제함으로 캐시 기능에 한계

### 스토리지 엔진

- sql query로 db에 저장된 디스크나 메모리에서 필요한 데이터를 가져와 MySQL 엔진으로 보냄
- 데이터 저장 방식에 따라 다름

### SQL 프로세스

SQL 실행 과정에서 핵핵심 오브젝트: 파서, 전처리기(preprocessor), optimizer, 엔진 실행기

- 파서: mysql 엔진에 속함. sql 쿼리를 최소 단위로 쪼개 문법 검사를 하며 트리로 만듦.
- 전처리기: = mysql 엔진. 파서에서 생성한 트리로 구조적 문제가 없는지 검사. (접근 권한 있는지 등)
- 옵티마이저: mysql의 핵심 엔진 중 하나. 전달된 파서 트리에서 **필요없는 조건 삭제, 연산 단순화. 어떤 순서로 테이블에 접근할지, 무슨 인덱스 쓸지 등 실행 계획을 수립** 단, 실행 계획 경우의 수가 너무 많으면 모든 실행계획을 계산하진 않아서 옵티마이저가 선택한 최적의 실행 계획이 무조건 best는 아닐 수도 있음
- 엔진 실행기(engine executor): Mysql 엔진과 스토리지 엔진 영역 모두에 걸침. 실행 계획을 참고해 스토리지 엔진에서 데이터를 가져옴. 이후 읽어온 데이터를 정렬하거나 조인, 불필요한 데이터는 필터링. 따라서 **mysql 엔진의 부하를 줄이려면 스토리지 엔진에서 가져오는 데이터양을 줄이는게 매우 중요**

### DB 오브젝트들

- 인덱스: DB에서 키값으로 실제 데이터 위치를 식별해 데이터 접근 속도를 높이고자 생성되는, 키 기준으로 정렬된 오브젝트
- 뷰: 가상 테이블. 뷰를 만들어 제한된 정보만 제공 가능. 여러 테이블을 join해 최적화된 뷰를 생성하면 좋음
- 쿼리 안에 중첩쿼리 있는 경우 SELECT (스칼라 섭쿼리) FROM (인라인 뷰) WHERE (중첩 섭쿼리)
- 비상관 서브쿼리: 메인, 서브쿼리가 독립적으로 실행가능한 경우. 서브쿼리 -> 메인쿼리 순서로 실행됨
- 상관 서브쿼리: 메인 -> 서브 -> 다시 메인 쿼리 순서로 실행

### 조인 알고리즘

- driving, driven 테이블: join B on A.col = B.col인 것처럼 먼저 접근하는게 드라이빙 테이블, 그 결과로 접근하는 테이블이 드리븐 테이블. **드라이빙 테이블에서 많은 건이 반환되면 그 결과를 가지고 드리븐 테이블에 접근하므로 최대한 적은 결과가 리턴될 것 같은 테이블을 드라이빙 테이블로 구성해야함**
- nested loop join: 드라이빙 테이블의 데이터 1건당 드리븐 테이블을 검색하는 것을 반복해 최종적으로 양쪽 테이블에 공통된 데이터를 출력
