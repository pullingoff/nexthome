---
title: "논리-물리 메모리 주소 바인딩, 동적 로딩과 프로세스를 연속적으로 메모리에 적재하는 법"
date: 2022-03-07 08:00
tags:
- 운영체제
description: 
---

메모리 참조를 하기 위해선 CPU가 논리 메모리 주소를 주면 물리 메모리 주소로 바꿔야한다. 
하드웨어가 해줘야하는 역할들과 메모리 주소 바인딩 방법에 대해 배워보자.

## 논리 주소 vs. 물리 주소

### 논리 주소 (virtual address)

- 프로그램이 실행되면 생기는 독자적인 주소 공간
- 각 프로세스마다 0번지부터 시작
- **CPU가 보는 주소**

### 물리 주소

- 메모리에 실제 올라가는 위치

### 주소 바인딩

- 주소를 결정하는 것
- symbolic address(컴파일)-> logical address(실행을 위해 주소 변환)-> physical address
- 프로그래머 입장에선 숫자가 아닌 symbolic address를 사용.

![주소 바인딩 예시](/images/os/osmm1.png)

- 소스코드: 심볼릭 주소(A,B)가 쓰임. "A,B를 더한 후 C로 점프하라"
- 실행파일: 심볼릭 주소가 논리 주소(20,30)로 바뀜. 각각의 문장이 메모리 0번지~40번지에 들어감.
- 실행시작: 물리적 메모리에 올라간다(= 주소 바인딩된다.)

## 주소 바인딩의 시점

### 컴파일 시점 바인딩

- 컴파일 시점에 이미 물리적 메모리 주소가 결정됨 => 컴파일러가 절대 코드(absolute code) 생성
- 메모리 주소 시작 위치 변경시 재컴파일 해야함
- 실행파일에 있는 `Add '20,30'` 이 논리 주소가 그대로 사용됨. -> **비효율적**
- 컴퓨터 안에서 프로그램이 1개만 실행될 때 그나마 나음

### 실행 시점 바인딩 (Load time)

- 프로그램이 실행 시작되면 물리적 메모리 주소 결정됨
- 로더의 책임 하에 물리적 메모리 주소 부여
- 컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우에 가능, 빈 위치에는 실행 시 어디든 올라갈 수 있음

### 런타임 바인딩

- 실행시에 프로세스 메모리 주소가 결정되는건 로드타임 바인딩과 같으나 **프로그램 실행중에도 주소가 바뀔 수 있음**
 (메모리에서 쫓겨난다거나)
- CPU가 주소를 참조할 때마다 바인딩이 어디 됐는지 체크해봐야한다. (address mapping table)
- 주소 참조시마다 바인딩 위치 확인하려면 하드웨어의 지원이 필요함 (base and limit registers, MMU)
- MMU가 주소 변환을 그때그때 해준다.

#### CPU는 물리 주소를 바라볼까?

CPU가 하드웨어라 물리 주소를 바라볼 것 같지만 바라보는 주소는 논리 주소다.  
프로그램이 실행돼 메모리에 올라가도 명령어 코드에 있는 주소는 논리 주소다(load time binding).  
메모리에 올라갈때 시작 위치(`500~`)는 바뀌지만 그 안의 주소는 논리주소로 남아있기 때문임.  

### MMU (Memory Management Unit)

- 논리 주소를 물리 주소로 매핑해주는 하드웨어
- 2개의 레지스터 사용 (base(relocation) register + limit register)
- 방법: 사용자 프로세스가 CPU에서 수행되며 생성하는 모든 주소값에 base register의 값을 더한다.
  
#### MMU 동작 원리 (Dynamic Relocation)

![dynamic relocation](/images/os/osmm2.png)

- 프로세스 P1은 논리주소: `0~3000번지` / 물리주소: `14000번지~`
- CPU 왈: 0번지 ~ 346번지 주셈  
=> 프로그램의 논리주소(346)+시작위치(14000) = 물리주소(14346)

#### 리밋(Limit) 레지스터

- 논리 주소 범위(끝)를 기억한다.
- 만약 악의적인 프로그램이 **실제 자기가 있지 않은 논리 주소를 달라고 하면?** 물리주소가 달라진다. 
=> 다른 프로그램의 피지컬 메모리 주소 주는 걸 방지하기 위해 리밋 레지스터를 사용

##### CPU가 논리 주소로 요청 -> 논리 주소가 리밋 레지스터의 범위 내에 있는지 확인 
-> 리밋 레지스터 범위를 벗어나면 트랩(소프트웨어 인터럽트) 발생시킴 -> 악의적 접근이 아니었으면 relocation(base) register로 주소 변환

=> 그 결과 프로그램은 논리 주소만 다르고, 실제 물리 주소는 알 필요가 없음.

## Dynamic Loading (동적 로딩)

- 프로세스 전체를 메모리에 미리 다 올리는 게 아니라 해당 **루틴이 호출되면 메모리에 로드**
- 메모리를 효율적으로 사용 가능
- 가끔씩 쓰는 많은 양의 코드를 쓸 때 유용 (e.g. 오류 처리 루틴)
- 운영체제가 지원하는게 아니라 라이브러리를 지원해주면 프로그래머가 프로그램 내에 구현

## Overlays (매뉴얼 오버레이)

- 프로세스의 실제 필요한 정보만 메모리에 올림
- 프로세스의 크기가 메모리보다 클 때 유용
- 프로그래머가 직접 메모리에 올렸다 내렸다~ 구현하는거고 프로그래밍이 매우 복잡

## 스와핑

- 프로세스를 일시적으로 backing store로 내쫓는 것
- 중기 스케줄러(스와퍼)가 우선순위 낮은 프로세스를 골라서 swap out
- `swap out`: backing store(swap area)로 내쫓음
- `swap in`: backing store(swap area)에서 다시 불러들임
- 컴파일/ 로드 타임 바인딩이면 돌아올 때 메모리 원래 위치로 돌아와야하기 때문에 별로 쓸데 없음.
- **런타임 바인딩할 때 써서 추후 빈 메모리 영역 아무데나로 가져오는게 가장 효율적임**
- 메모리에서 상당히 방대한 양을 내쫓거나/ 가져오는 거기 때문에 디스크 접근하는 시간의 대부분이 데이터 전송 시간(transfer time)이다. swap 되는 양에 비례함.

## Linking

- 프로그램을 작성하고 컴파일한 후 그 컴파일 된 파일들을 모아 실행파일로 만드는 것

### Static Linking

- **라이브러리가 프로그램의 실행 파일 코드에 포함됨** -> 실행 파일의 크기가 커짐
- 동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비 (e.g. `printf` 함수의 라이브러리 코드)

### Dynamic Linking (동적 연결)

- 라이브러리가 실행파일 코드에 들어가지 않고 **실행 시에 동적 연결됨**
- 라이브러리 호출 부분에 **라이브러리 루틴의 위치를 찾는 stub**이라는 작은 코드를 둔다.
- 라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고, 없으면 디스크에서 읽어온다
- 운영체제의 도움이 필요

## 물리적 메모리

![allocation of physical memory](/images/os/osmm3.png)

- 연속 할당: 프로세스 하나가 메모리의 연속적인 공간에 적재됨
- 불연속 할당: 프로세스 하나를 나눠서 메모리의 여러 영역에 분산해 올림

## 연속 할당

![메모리 연속 할당](/images/os/osmm4.png)

### 고정 분할 방식

- 프로그램이 들어갈 물리적 메모리 영역을 미리 영구적으로 나눠놓음 (partition)
- 융통성이 없음. 최대 수행 가능한 프로그램의 크기가 제한되어있음.
- fragmentation(조각) 발생: 프로그램B가 분할3에 들어갔지만 남음. 프로그램B에게 할당됐지만 사용 안되는 부분 등

### 가변 분할 방식

- 분할의 크기, 갯수가 동적으로 변함
- B가 끝나고 D가 수행되는데 B가 들어갔던 부분은 D에게는 작아서 B가 끝나도 다른 자리로 들어감

#### Hole

![](/images/os/osmm5.png)

- 사진 속 노란 공간이 hole (가용 공간)
- 프로세스가 도착하면 hole에 넣는다.

#### 동적 저장공간 할당(dynamic storage allocation) 문제 (알고리즘)

: 가변 분할 방식에서 size n인 요청을 만족하는 가장 적절한 hole 을 찾는 문제

1. First-fit: size가 n 이상인 것 중 맨 처음으로 찾은 hole에 할당
2. Best-fit: size가 n 이상인 가장 작은 hole을 찾아서 할당 / 
홀의 리스트가 크기순 정렬아닌 경우 모든 hole을 탐색하는데 시간 소요
3. Worst-fit: 가장 큰 hole에 할당. 역시 모든 리스트를 탐색해야함. 상대적으로 아주 큰 hole들이 생성됨.

=> First-fit, best-fit이 worst-fit보다 속도/공간 이용률 측면에서 효과적임

#### Compaction

- 외부조각으로 생기는 hole을 한군데로 몰아 아주 큰 hole로 모아 큰 block으로 만듦
- 매우 비용이 많이 드는 방법임
- 런타임 바인딩이 지원되어야 가능함.
