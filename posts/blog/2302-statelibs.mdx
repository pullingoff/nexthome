---
title: "redux vs. recoil vs. jotai"
date: 2023-02-11 12:00
description: 리액트 상태관리 라이브러리 비교 (작성중)
tags:
- 상태관리
---

상태: 앱의 동작 방식을 설명하는 모든 데이터

**상태 '관리'의 조건**
- 최초 값(initial value)을 저장
- 현재 값(current value)를 읽기
- 값을 업데이트

React 상태 관리 로직의 한계점
- props drilling, props bubbling
- Context API는 확정되지 않은 수의 값을 저장하는데 적합하지 않고 최적화 관점에서 한계가 명확하다.
또 높은 곳 -> 자식, 손자 컴포넌트로 줌으로 많은 데이터를 많은 컴포넌트에 주게 된다.
- Context API는 상태 관리라기보단 의존성 주입(Dependency Injection)에 가깝다. (`Provider`라는 파이프 시작점에서 `Consumer`라는 파이프 끝으로 이어지는)

## Recoil
- React의 내장 상태 관리 기능의 한계점 극복
- 최대한 리액트스러운 API 유지 (리액트 유저들의 러닝커브 낮음)
- 사용하기 위한 부속 라이브러리 최소화
	- redux (redux-thunk, redux-saga 등...)

### Recoil의 접근 방법
- redux의 경우 redux, react가 따로 있고 react-redux가 전달해줘야했음. 반면 recoil은 directed graph를 따라 리액트 컴포넌트로 바로 흘러들어감.

### Recoil의 철학
- 보일러 플레이트는 적게, 리액트의 로컬 상태(useState, useReducer)와 유사한 인터페이스
- **파생 데이터**를 사용함으로써 데이터를 사용하는 컴포넌트에서 임의로 데이터를 바꾸는 로직을 가져가지 않아도 된다. 
	- 가져와서 useEffect로 바꿔주기 하지 않고, 로직 자체를 recoil atom에 귀속시킬 수 있다.

## Recoil의 Core Concept

### flexible shared state: 유연하게 상태 관리

- context api에서는 데이터를 동적 생성했을 경우 변화 주기가 어렵고 변화를 줄 경우 전체 트리가 새로 렌더링된다. 또 Provider, Consumer가 각각 트리의 root, leaf에 존재하다보니 커플링 현상이 발생한다. => 렌더링 최적화에 이슈가 생길수도. (context api는 잘 바뀌지 않는 데이터를 쓸 때 좋다.)
- 리액트의 로컬 컴포넌트 상태(useState, useReducer)처럼 batching 같은 작업이 모두 라이브러리 내부에서 처리된다.

### derived data and queries: 파생 데이터

예를 들어 화면에 사각형 두개를 그리고 이 두개가 겹치는지 안 겹치는지 확인하고 싶다면 사각형 두개의 위치와 **그 두 위치를 계산해 판별한 겹침 여부 상태**가 따로 필요할까?

redux에서는 `layeredItemKey`를 사각형 데이터에 넣어놓고 겹칠때마다 업데이트하는 로직을 넣어준다. 
만약 그냥 컴포넌트에서 판별하게 하려면? `useEffect`에 `layeredItemKey` 관련 로직을 넣어도 된다. 
근데 이러면 로직이 컴포넌트 안으로 들어가게 된다. 커스텀 훅으로 뺀다고 해도 컴포넌트가 여러개 생길때 커스텀훅을 다시 잡아다가 넣어줘야한다.

recoil에서는 `layeredItemKey`(겹친 사각형 key) 데이터를 `selector`가 dependency 있는 애들을 가지고 있다가 위치 데이터가 바뀔때 recompute한다.
즉, **상호의존적인 상태를 만들 필요가 없다. & 리액트 사이드에서 고민할 필요가 없다.**
파생 데이터를 만들어두고 observing하고 있다가 데이터가 바뀌었을 때만 재계산한다.(mobX와 비슷. mobX 만든사람이 만듦)

- `Atom`: 데이터를 보관하는 기본 단위, redux의 reducer과 유사하지만 전체 Store의 일부분
- `Selector`: atom이나 다른 셀렉터들을 조합할 수 있음, 파생되는 상태를 생성, dependency인 atom이 업데이트되면 같이 업데이트되므로 관리가 용이.

### React API와 비슷한 API들

recoil의 atom과 selector는 동일한 API를 쓴다.

- `useRecoilState`: `useState`와 똑같이 getter, setter 가짐
- `useRecoilCallback` : `useCallback`은 메모이징된 함수를 사용하기 위해 쓴다. 
그냥 `useCallback`을 써도 문제는 없지만 dependency array가 더럽혀질 수 있다. 
`useRecoilCallback`은 리코일 자체가 스냅샷을 읽어서 리액트 컴포넌트 내부에서 사용 가능. 

### App-wide state observation: 앱 단에서 상태 관찰 기능
