---
title: "리액트 Hooks 중 useEffect()에 대해 알아보자"
date: 2021-08-22 08:00
tags:
- React
- Hooks
description: 컴포넌트 마운트와 관련해 발생하는 사이드이펙트를 이용하는 리액트 훅!
---

## useEffect

- useEffect: `componentDidMount`, `componentDidUpdate` 이후에 발생하는 코드를 넣음
- 순수 함수는 참조 투명성을 가지는데 (부작용이 없음) useEffect는 이름에서 드러나듯 [함수 컴포넌트가 부작용을 이용하는 도구](https://gyuwon.github.io/blog/2020/07/24/react-has-no-functional-components.html)다.
- 계속 마운트되는 부분의 라이프사이클을 관리
- 클래스 컴포넌트에서는 `componentDidMount()` 등의 함수를 썼었는데 넘 번거로워서 생김

### useEffect()를 쓰는 경우

`setInterval`로 1초마다 초를 업데이트하는 함수가 있다.

```javascript
function App() {
  const [second, setSecond] = useState(0);

  setInterval(() => {
    setSecond(second +1);
  },1000);

  return (
    <div>
      <p>{second}초</p>
    </div>
  )
}
```

이 함수의 문제점은 1초마다 함수 전체가 새로 **마운트** 된다는 거다.  
그러면 `setInterval` 함수를 또 시작한다.  

![console log](/images/blog/192021/eff.png)

setInterval 안에서 `console.log` 함수를 찍으면 이렇게 이상한 결과가 나온다.  
`setInterval()` 함수가 대략 1초마다 계속 실행되며 점점 쌓인다.  
이런 경우에 useEffect()를 사용하면 된다!

```javascript
function App() {
  const [second, setSecond] = useState(0);

  useEffect(()=> {
    let interval = setInterval(()=> {
      console.log(second);
      setSecond(second+1);
    }, 1000);

    return () => {
      clearInterval(interval);
    }
  }, [second]);

  return (
    <div className="App">
      <p>{second}초</p>
    </div>
  )
}
```

이렇게 하면 마운트, 언마운트가 반복되며 second가 1초마다 1씩 늘어난다.

```javascript
useEffect(() => {
  
  console.log("mount")
  return () => {
    console.log("unmound')         # 마운트, 언마운트 반복해 나타남
    언마운트 시에 실행                # 언마운트(cleanup) 안 하면 반복 요청이 발생
  }
}, [second]);                    # mount에 의존적인 변수(dependencies) 삽입
```
